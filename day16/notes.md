It was a fairly straightforward problem that just needed to be implemented one step at a time. First making sure I have a way to handle beams that exit or are stuck in an infinite loop. Then handling the beam's next position and marking it accordingly. And then handling the tile. To keep track of the beams, I made a struct for each beam's coordinates, direction and state, and created a vector of structs. Everytime a beam is split, I added an extra beam to the vector. Otherwise, I'd move the existing beams forward as far as they'd go without exiting or looping.

I almost didn't do it right. In my initial implementation, instead of dealing with the current tile first, I had it so that the direction is assumed to be correct on the current tile, and I would set the beam's direction for the next tile as I move it there. It worked okay for most of the grid, however, the problem arised with the initial beam. As it entered, it had a certain direction, but my logic assumed that to be the direction for the next tile. It worked for the test input because the first tile was a '.', but the real input, the first tile was a mirror and it didn't work. I cheated it by changing the direction of the initial beam to be down to get the answer but then I moved my direciton handling up, before I move the beam forward. And I'm glad I did. Because the next problem had us test all the possible beam entrypoints and their respective directions